(function() {
  var NoEmptyFunctions, isEmptyCode;

  isEmptyCode = function(node, astApi) {
    var nodeName;
    nodeName = astApi.getNodeName(node);
    return nodeName === 'Code' && node.body.isEmpty();
  };

  module.exports = NoEmptyFunctions = (function() {
    class NoEmptyFunctions {
      lintAST(node, astApi) {
        this.lintNode(node, astApi);
        return void 0;
      }

      lintNode(node, astApi) {
        var error;
        if (isEmptyCode(node, astApi)) {
          error = astApi.createError({
            lineNumber: node.locationData.first_line + 1,
            columnNumber: node.locationData.first_column + 1
          });
          this.errors.push(error);
        }
        return node.eachChild((child) => {
          return this.lintNode(child, astApi);
        });
      }

    };

    NoEmptyFunctions.prototype.rule = {
      name: 'no_empty_functions',
      level: 'ignore',
      message: 'Empty function',
      description: 'Disallows declaring empty functions. The goal of this rule is that\nunintentional empty callbacks can be detected:\n<pre>\n<code>someFunctionWithCallback ->\ndoSomethingSignificant()\n</code>\n</pre>\nThe problem is that the call to\n<tt>doSomethingSignificant</tt> will be made regardless\nof <tt>someFunctionWithCallback</tt>\'s execution. It can\nbe because you did not indent the call to\n<tt>doSomethingSignificant</tt> properly.\n\nIf you really meant that <tt>someFunctionWithCallback</tt>\nshould call a callback that does nothing, you can write your code\nthis way:\n<pre>\n<code>someFunctionWithCallback ->\n    undefined\ndoSomethingSignificant()\n</code>\n</pre>'
    };

    return NoEmptyFunctions;

  }).call(this);

}).call(this);
