(function() {
  var NoImplicitParens;

  module.exports = NoImplicitParens = (function() {
    class NoImplicitParens {
      lintToken(token, tokenApi) {
        var genCallStart, i, sameLine, t;
        if (token.generated) {
          if (tokenApi.config[this.rule.name].strict !== false) {
            return {token};
          } else {
            // If strict mode is turned off it allows implicit parens when
            // the expression is spread over multiple lines.
            i = -1;
            while (true) {
              t = tokenApi.peek(i);
              sameLine = t[2].first_line === token[2].first_line;
              genCallStart = t[0] === 'CALL_START' && t.generated;
              if ((t == null) || genCallStart && sameLine) {
                return {
                  token: t || token
                };
              }
              // If we have not found a CALL_START token that is generated,
              // and we've moved into a new line, this is fine and should
              // just return.
              if (!sameLine) {
                return null;
              }
              i -= 1;
            }
          }
        }
      }

    };

    NoImplicitParens.prototype.rule = {
      name: 'no_implicit_parens',
      level: 'ignore',
      message: 'Implicit parens are forbidden',
      strict: true,
      description: 'This rule prohibits implicit parens on function calls.\n<pre>\n<code># Some folks don\'t like this style of coding.\nmyFunction a, b, c\n\n# And would rather it always be written like this:\nmyFunction(a, b, c)\n</code>\n</pre>\nImplicit parens are permitted by default, since their use is\nidiomatic CoffeeScript.'
    };

    NoImplicitParens.prototype.tokens = ['CALL_END'];

    return NoImplicitParens;

  }).call(this);

}).call(this);
