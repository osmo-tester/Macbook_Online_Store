(function() {
  var NoTrailingSemicolons, regexes,
    indexOf = [].indexOf,
    splice = [].splice;

  regexes = {
    trailingSemicolon: /;\r?$/
  };

  module.exports = NoTrailingSemicolons = (function() {
    class NoTrailingSemicolons {
      lintLine(line, lineApi) {
        var endPos, first, hasNewLine, hasSemicolon, last, lineTokens, newLine, ref, ref1, startCounter, startPos, stopTokens, tokenLen;
        // The TERMINATOR token is extended through to the next token. As a
        // result a line with a comment DOES have a token: the TERMINATOR from
        // the last line of code.
        lineTokens = lineApi.getLineTokens();
        tokenLen = lineTokens.length;
        stopTokens = ['TERMINATOR', 'HERECOMMENT'];
        if (tokenLen === 1 && (ref = lineTokens[0][0], indexOf.call(stopTokens, ref) >= 0)) {
          return;
        }
        newLine = line;
        if (tokenLen > 1 && lineTokens[tokenLen - 1][0] === 'TERMINATOR') {
          // `startPos` contains the end pos of the last non-TERMINATOR token
          // `endPos` contains the start position of the TERMINATOR token

          // if startPos and endPos arent equal, that probably means a comment
          // was sliced out of the tokenizer
          startPos = lineTokens[tokenLen - 2][2].last_column + 1;
          endPos = lineTokens[tokenLen - 1][2].first_column;
          if (startPos !== endPos) {
            startCounter = startPos;
            while (line[startCounter] !== '#' && startCounter < line.length) {
              startCounter++;
            }
            newLine = line.substring(0, startCounter).replace(/\s*$/, '');
          }
        }
        hasSemicolon = regexes.trailingSemicolon.test(newLine);
        [...first] = lineTokens, [last] = splice.call(first, -1);
        hasNewLine = last && (last.newLine != null);
        // Don't throw errors when the contents of multiline strings,
        // regexes and the like end in ";"
        if (hasSemicolon && !hasNewLine && lineApi.lineHasToken() && !((ref1 = last[0]) === 'STRING' || ref1 === 'IDENTIFIER' || ref1 === 'STRING_END')) {
          return true;
        }
      }

    };

    NoTrailingSemicolons.prototype.rule = {
      name: 'no_trailing_semicolons',
      level: 'error',
      message: 'Line contains a trailing semicolon',
      description: 'This rule prohibits trailing semicolons, since they are needless\ncruft in CoffeeScript.\n<pre>\n<code># This semicolon is meaningful.\nx = \'1234\'; console.log(x)\n\n# This semicolon is redundant.\nalert(\'end of line\');\n</code>\n</pre>\nTrailing semicolons are forbidden by default.'
    };

    return NoTrailingSemicolons;

  }).call(this);

}).call(this);
