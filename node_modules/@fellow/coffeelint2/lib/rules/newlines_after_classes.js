(function() {
  var NewlinesAfterClasses;

  module.exports = NewlinesAfterClasses = (function() {
    class NewlinesAfterClasses {
      lintToken(token, tokenApi) {
        var afters, befores, comment, ending, got, lineNumber, lines, numIndents, outdent, ref, ref1, start, trueLine, type;
        [
          type,
          numIndents,
          {
            first_line: lineNumber
          }
        ] = token;
        ({lines} = tokenApi);
        ending = tokenApi.config[this.rule.name].value;
        if (type === 'CLASS') {
          this.classCount++;
        }
        if (this.classCount > 0 && (token.generated != null)) {
          if (type === '{' && ((ref = token.origin) != null ? ref[0] : void 0) === ':') {
            this.classBracesCount++;
          }
          if (type === '}' && ((ref1 = token.origin) != null ? ref1[0] : void 0) === 'OUTDENT') {
            this.classBracesCount--;
            this.classCount--;
            if (this.classCount === 0 && this.classBracesCount === 0) {
              befores = 1;
              afters = 1;
              comment = 0;
              outdent = token.origin[2].first_line;
              start = Math.min(lineNumber, outdent);
              trueLine = 2e308;
              while (/^\s*(#|$)/.test(lines[start + afters])) {
                if (/^\s*#/.test(lines[start + afters])) {
                  comment += 1;
                } else {
                  trueLine = Math.min(trueLine, start + afters);
                }
                afters += 1;
              }
              while (/^\s*(#|$)/.test(lines[start - befores])) {
                if (/^\s*#/.test(lines[start - befores])) {
                  comment += 1;
                } else {
                  trueLine = Math.min(trueLine, start - befores);
                }
                befores += 1;
              }
              // add up blank lines, subtract comments, subtract 2 because
              // before/after counters started at 1.
              got = afters + befores - comment - 2;
              // if `got` and `ending` don't match throw an error _unless_
              // we are at the end of the file.
              if (got !== ending && trueLine + ending <= lines.length) {
                return {
                  context: `Expected ${ending} got ${got}`,
                  lineNumber: trueLine
                };
              }
            }
          }
        }
      }

    };

    NewlinesAfterClasses.prototype.rule = {
      name: 'newlines_after_classes',
      value: 3,
      level: 'ignore',
      message: 'Wrong count of newlines between a class and other code',
      description: '<p>Checks the number of newlines between classes and other code.</p>\n\nOptions:\n- <pre><code>value</code></pre> - The number of required newlines\nafter class definitions. Defaults to 3.'
    };

    NewlinesAfterClasses.prototype.tokens = ['CLASS', '}', '{'];

    NewlinesAfterClasses.prototype.classBracesCount = 0;

    NewlinesAfterClasses.prototype.classCount = 0;

    return NewlinesAfterClasses;

  }).call(this);

}).call(this);
