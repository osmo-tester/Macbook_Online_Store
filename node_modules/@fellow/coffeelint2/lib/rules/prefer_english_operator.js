(function() {
  var PreferEnglishOperator,
    indexOf = [].indexOf;

  module.exports = PreferEnglishOperator = (function() {
    class PreferEnglishOperator {
      lintToken(token, tokenApi) {
        var actual_token, config, context, first_column, last_column, level, line;
        config = tokenApi.config[this.rule.name];
        level = config.level;
        // Compare the actual token with the lexed token.
        ({first_column, last_column} = token[2]);
        line = tokenApi.lines[tokenApi.lineNumber];
        actual_token = line.slice(first_column, +last_column + 1 || 9e9);
        context = (function() {
          var ref, ref1;
          switch (true) {
            case actual_token === '==' && indexOf.call(config.ops, 'is') >= 0:
              return 'Replace "==" with "is"';
            case actual_token === '!=' && indexOf.call(config.ops, 'isnt') >= 0:
              return 'Replace "!=" with "isnt"';
            case actual_token === '||' && indexOf.call(config.ops, 'or') >= 0:
              return 'Replace "||" with "or"';
            case actual_token === '&&' && indexOf.call(config.ops, 'and') >= 0:
              return 'Replace "&&" with "and"';
            case actual_token === '!' && indexOf.call(config.ops, 'not') >= 0:
              // `not not expression` seems awkward, so `!!expression`
              // gets special handling.
              if (((ref = tokenApi.peek(1)) != null ? ref[0] : void 0) === 'UNARY_MATH') {
                level = config.doubleNotLevel;
                return '"?" is usually better than "!!"';
              } else if (((ref1 = tokenApi.peek(-1)) != null ? ref1[0] : void 0) === 'UNARY_MATH') {
                // Ignore the 2nd half of the double not
                return void 0;
              } else {
                return 'Replace "!" with "not"';
              }
              break;
            default:
              return void 0;
          }
        })();
        if (context != null) {
          return {token, level, context};
        }
      }

    };

    PreferEnglishOperator.prototype.rule = {
      name: 'prefer_english_operator',
      level: 'ignore',
      message: 'Don\'t use &&, ||, ==, !=, or !',
      doubleNotLevel: 'ignore',
      ops: ['and', 'or', 'not', 'is', 'isnt'],
      description: 'This rule prohibits &&, ||, ==, != and !.\nUse and, or, is, isnt, and not instead.\n!! for converting to a boolean is ignored.'
    };

    PreferEnglishOperator.prototype.tokens = ['COMPARE', 'UNARY_MATH', '&&', '||'];

    return PreferEnglishOperator;

  }).call(this);

}).call(this);
