(function() {
  var BracesSpacing;

  module.exports = BracesSpacing = (function() {
    class BracesSpacing {
      distanceBetweenTokens(firstToken, secondToken) {
        return secondToken[2].first_column - firstToken[2].last_column - 1;
      }

      findNearestToken(token, tokenApi, difference) {
        var nearestToken, totalDifference;
        totalDifference = 0;
        while (true) {
          totalDifference += difference;
          nearestToken = tokenApi.peek(totalDifference);
          if (nearestToken[0] === 'OUTDENT' || (nearestToken.generated != null)) {
            continue;
          }
          return nearestToken;
        }
      }

      tokensOnSameLine(firstToken, secondToken) {
        return firstToken[2].first_line === secondToken[2].first_line;
      }

      getExpectedSpaces(tokenApi, firstToken, secondToken) {
        var config, ref;
        config = tokenApi.config[this.rule.name];
        if (firstToken[0] === '{' && secondToken[0] === '}') {
          return (ref = config.empty_object_spaces) != null ? ref : config.spaces;
        } else {
          return config.spaces;
        }
      }

      lintToken(token, tokenApi) {
        var actual, expected, firstToken, msg, secondToken;
        if (token.generated) {
          return null;
        }
        [firstToken, secondToken] = token[0] === '{' ? [token, this.findNearestToken(token, tokenApi, 1)] : [this.findNearestToken(token, tokenApi, -1), token];
        if (!this.tokensOnSameLine(firstToken, secondToken)) {
          return null;
        }
        expected = this.getExpectedSpaces(tokenApi, firstToken, secondToken);
        actual = this.distanceBetweenTokens(firstToken, secondToken);
        if (actual === expected) {
          return null;
        } else {
          msg = `There should be ${expected} space`;
          if (expected !== 1) {
            msg += 's';
          }
          msg += ` inside "${token[0]}"`;
          return {
            token,
            context: msg
          };
        }
      }

    };

    BracesSpacing.prototype.rule = {
      name: 'braces_spacing',
      level: 'ignore',
      spaces: 0,
      empty_object_spaces: 0,
      message: 'Curly braces must have the proper spacing',
      description: 'This rule checks to see that there is the proper spacing inside\ncurly braces. The spacing amount is specified by "spaces".\nThe spacing amount for empty objects is specified by\n"empty_object_spaces".\n\n<pre><code>\n# Spaces is 0\n{a: b}     # Good\n{a: b }    # Bad\n{ a: b}    # Bad\n{ a: b }   # Bad\n\n# Spaces is 1\n{a: b}     # Bad\n{a: b }    # Bad\n{ a: b}    # Bad\n{ a: b }   # Good\n{ a: b  }  # Bad\n{  a: b }  # Bad\n{  a: b  } # Bad\n\n# Empty Object Spaces is 0\n{}         # Good\n{ }        # Bad\n\n# Empty Object Spaces is 1\n{}         # Bad\n{ }        # Good\n</code></pre>\n\nThis rule is disabled by default.'
    };

    BracesSpacing.prototype.tokens = ['{', '}'];

    return BracesSpacing;

  }).call(this);

}).call(this);
